# JAVA 知识点总结

## 一.JVM基础

**常见JVM**

1. Sun Classic
2. HotSpot VM
3. IBM J9 VM
4. Azul VM
5. Dalvik VM
6. Graal VM（下一代VM）

**JVM内存结构**

  <img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/memory-struct.jpg" height=300/>
1. 程序计数器：当前线程执行字节码的行号指示器，线程私有，无OOM（唯一）

2. 虚拟机栈：虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

   > 当线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；

   > 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

3. 本地方法栈：本地方法栈则是为虚拟机使用到的本地（Native） 方法服务。

   > 在栈深度溢出或者栈扩展 败时分别抛出StackOverflowError和OutOfMemoryError异常。

4. 堆（Heap）：Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。

5. 元空间（Metaspace）：

   > 如果在Java堆中没有内存完成实例分配，并且堆也无法再 扩展时，Java虚拟机将会抛出OutOfMemoryError异常。

6. 直接内存

**JVM类加载器**

* 类的生命周期：

    > 加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 --> 卸载

* 三类加载器：
    1. 启动类加载器
    2. 扩展类加载器
    3. 应用类加载器

    特点：双亲委托、负责依赖、缓存加载

**GC策略**

​    分代假设：大部分新生对象很快无用，存活较长时间的对象，可能存活更长时间。

1. 标记清除
2. 标记复制
3. 标记整理

**常见垃圾收集器**

1. Serial GC（串行GC）：
2. Parallel GC（并行GC）：
3. CMS GC
4. G1
5. ZGC
6. Shenandoah GC
* GC的演进：

  串行 -> 并行: 重复利用多核 CPU 的优势，大幅降低 GC 暂停时间，提升吞吐量。  

  并行 -> 并发: 不只开多个 GC 线程并行回收，还将GC操作拆分为多个步骤，让很多繁重的任务和应用线程一起并 发执行，减少了单次 GC 暂停持续的时间，这能有效降低业务系统的延迟。  

  CMS -> G1: G1 可以说是在 CMS 基础上进行迭代和优化开发出来的，划分为多个小堆块进行增量回收，这样就更 进一步地降低了单次 GC 暂停的时间  

  G1 -> ZGC::ZGC 号称无停顿垃圾收集器，这又是一次极大的改进。ZGC 和 G1 有一些相似的地方，但是底层的算法 和思想又有了全新的突破。

## 二.NIO

### I/O模型

* 同步和异步
> 阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回;  
> 非阻塞：非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程  
> 同步：指被调用方得到最终结果之后才返回给调用方  
> 异步：指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方

1. 同步阻塞I/O
   <img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/io-mode-1.png" height=280/>
   应用程序在从调用 recvfrom 开始到它返回有数据报准备好这段时间是阻塞的，recvfrom 返回成功后，应用进程开始处理数据报。

2. 同步非阻塞I/O
   <img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/io-mode-2.png" height=280/>
   应用程序把一个套接字设置为非阻塞，告诉内核当所请求的 I/O 操作无法完成时，不要将线程睡眠而是返回一个错误，应用程序基于 I/O 操作函数将不断的轮询数据是否已经准备好，如果没有准备好，继续轮询，直到数据准备好为止。

3. I/O多路复用（主流）
   <img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/io-mode-3.png" height=280/>
   IO多路复用模型是建立在内核提供的多路分离函数select，poll，epoll基础之上的，进行这些函数调用时线程依然会阻塞，但是和阻塞 I/O 有所不同。这两个函数可以同时阻塞多个 I/O 操作，而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。

4. 信号驱动式 I/O 
   <img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/io-mode-4.png" height=280/>
   允许套接字接口进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

5. 异步 I/O
   <img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/io-mode-5.png" height=280/>
   应用程序告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到应用程序的缓冲区）完成后通知应用程序，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内。

五种I/O模型的比较：  
| I/O模型     | 优点 | 缺点 |
| ----------- | ---- | ---- |
| 同步阻塞I/O | 程序简单，线程挂起时基本不占CPU资源 | 一个连接一个线程，内存、线程切换开销较大 |
| 同步非阻塞I/O | 不用阻塞等待，实时性较好 | 轮询占用大量的CPU时间，系统资源利用率较低 |
| I/O多路复用 | 一个阻塞对象同时在多个描述符上等待就绪，节省系统资源 | 连接数少时可能延迟增大 |
| 信号驱动式/O | 等待数据时不被阻塞，提高了资源的利用率 | 信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知 |
| 异步/O | 充分利用 DMA 特性，让 I/O 操作与计算重叠 | 操作系统需要做大量的工作，要求较高 |

### Netty

- Channel

  Channel 是 Netty 网络操作抽象类，代表一个打开的连接,可执行读取/写入 IO 操作。 Netty 对 Channel 的所有 IO 操作都是非阻塞的。

- ChannelFuture

  Netty 为异步非阻塞，即所有的 I/O 操作都为异步的，因此，我们不能立刻得知消息是否已经被处理了。Netty 提供了 ChannelFuture 接口，通过该接口的 addListener() 方法注册一个 ChannelFutureListener，当操作执行成功或者失败时，监听就会自动触发返回结果。

- EventLoop

  Netty 基于事件驱动模型，使用不同的事件来通知我们状态的改变或者操作状态的改变。它定义了在整个连接的生命周期里当有事件发生的时候处理的核心抽象。当一个连接到达时，Netty 就会注册一个 Channel，然后从 EventLoopGroup 中分配一个 EventLoop 绑定到这个Channel上，在该Channel的整个生命周期中都是有这个绑定的 EventLoop 来服务的。

- ChannelHandler

  ​	ChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。  
  ​	ChannelHandler 有两个核心子类 ChannelInboundHandler 和 ChannelOutboundHandler，其中 ChannelInboundHandler 用于接收、处理入站数据和事件，而 ChannelOutboundHandler 则相反。

- ChannelPipeline

  ChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API。一个数据或者事件可能会被多个 Handler 处理，在这个过程中，数据或者事件经流 ChannelPipeline，由 ChannelHandler 处理。

## Java 并发编程

### 并发核心问题

1. 原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性；  
2. 可见性： 一个线程修改了一个变量的值后，其他线程立即可以感知到这个值的修改；  
3. 有序性：如果在本线程内部观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。

  由于操作系统进行任务切换时可以发生在任何一条 CPU 指令执行完，所以要在高级语言层面保证操作的原子性；由于CPU核内存的水访问速度不一致，催生的CPU缓存带来了可见性问题；而导致有序性的原因则是编译优化。


### JAVA内存模型

> Java内存模型(Java Memory Model，JMM)规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括 volatile、synchronized 和 final 三个关键字，以及六项 Happens-Before 规则

***工作内存与主内存***

​    Java虚拟机规定所有的变量(不是程序中的变量)都必须在主内存中产生，为了方便理解，可以认为是堆区。可以与前面说的物理机的主内存相比，只不过物理机的主内存是整个机器的内存，而虚拟机的主内存是虚拟机内存中的一部分。  
​    Java虚拟机中每个线程都有自己的工作内存，线程的工作内存保存了线程需要的变量在主内存中的副本。  
​    虚拟机规定，线程对主内存变量的修改必须在线程的工作内存中进行，不能直接读写主内存中的变量。不同的线程之间也不能相互访问对方的工作内存。如果线程之间需要传递变量的值，必须通过主内存来作为中介进行传递。

**Happen-Before原则**

> 前面一个操作的结果对后续操作是可见的

1. 程序顺序性规则：在一个线程中按照程序顺序，前面的操作 Happens-Before 于后续的任意操作；  
2. volatile 变量规则：一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile 变量的读操作；  
3. 传递性：如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C；  
4. 管程中锁的规则：对一个锁的解锁 Happens-Before 于后续对这个锁的加锁  
4. 线程启动规则：Thread对象的start()方法先行发生与该线程的每个动作；  
5. 线程join()规则：线程 A 通过调用子线程 B 的 join() 方法实现，当子线程 B 完成后（线程 A 中 join() 方法返回），线程A能够看到子线程B的操作  
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；

### 线程和线程池

  > 线程是CPU调度执行的基本单位，Java语言中的线程属于重量级线程，一个运行中的Thread对象和操作系统内核线程一一对应。

**线程的生命周期**

1. 初始状态：编程线程已经被创建，但是还不允许分配 CPU 执行；  
2. 可运行状态：线程可以分配 CPU 执行（内核线程也已创建）；  
3. 运行状态：线程被分配到CPU时间片执行，状态转换成运行状态；  
4. 休眠状态：运行状态的线程如果调用了阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量），转换到休眠状态同时释放放 CPU 使用权；  
5. 终止状态：线程执行完或者出现异常就会进入终止状态  
 <img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/thread-status.png" height=280/>

Java语言中的线程生命周期略有不同，其共有以下6种状态：  
1. NEW（初始化状态）：  
2. RUNNABLE（可运行 / 运行状态）  
3.  BLOCKED（阻塞状态）  
4.  WAITING（无时限等待）  
5.  TIMED_WAITING（有时限等待）  
6.  TERMINATED（终止状态）  
<img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/thread-status2.png" height=280/>

**线程池**

  在Java中线程是一个重量级对象，属于昂贵资源，应该避免频繁的创建和销毁，于是线程池就应用而生了。

1. Excutor: 执行者 – 顶层接口  
2. ExcutorService: 接口 API  
3. ThreadPoolExecutor：核心实现类
4. ThreadFactory: 线程工厂  
5. Excutors: 工具类（不推荐使用）

  Java的中线程池的实现在内部维护了一个阻塞队列 workQueue 和一组工作线程；本质上是生产者 - 消费者模式的应用，线程池的使用方是生产者，线程池本身是消费者。

  ThreadPoolExecutor核心参数：  
| 参数名       | 含义 |
| ------------ | ---- |
| corePoolSize | 线程池保有的最小线程数 |
| maximumPoolSize | 线程池创建的最大线程数，随着任务数量变化线程数保持在corePoolSize和maximumPoolSize之间 |
| keepAliveTime & unit | 线程的回收空闲时间 |
| workQueue | 工作队列（慎用无界队列LinkedBlockingQueue） |
| threadFactory | 自定义如何创建线程工厂类 |
| handler | 自定义任务的拒绝策略 |

常见拒绝策略：  
* CallerRunsPolicy：提交任务的线程自己去执行该任务。  
* AbortPolicy：默认的拒绝策略，会 throws RejectedExecutionException。  
* DiscardPolicy：直接丢弃任务，没有任何异常抛出。  
* DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。



## 四.Spring&ORM

### Spring Framework

> Spring Framework 是一个开源的、松耦合的、分层的、可配置的一站式企业级 Java 开发框架，它的核心是 IOC 与 AOP ，它可以更容易的构建出企业级 Java 应用，并且它可以根据应用开发的组件需要，整合对应的技术。

* Spring framework模块划分  
  <img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/spring-framework.png" alt="Spring Framework" height=360/>

* IOC（控制反转）  

  > IOC 控制反转是一种思想，它的核心是将控制权转交出去。利用 IOC 思想，可以实现组件之间的解耦。IOC 的实现方式通常有依赖注入和依赖查找。

  依赖查找 DL 和依赖注入 DI 是 IOC 的具体实现，对比如下：  

  * 作用目标不同  
    依赖注入的作用目标通常是类成员（当然也可以是方法参数）  
    依赖查找的作用目标可以是方法体内，也可以是方法体外  
  * 实现方式不同  
    依赖注入通常借助一个上下文被动的接收（标注 `@Autowired` 或`<property>` 标签配置）  
    通常主动使用上下文搜索（拿到 BeanFactory / ApplicationContext 之后主动调用 getBean 方法）

* Spring Context的初始化流程

  1. 对刷新进行准备，包括设置开始时间、设置激活状态、初始化context环境中的占位符，这个动作根据子类的需求由子类来执行，然后验证是否缺失必要的properties；  
  2. 刷新并获得内部的bean factory；  
  3. 对bean factory进行准备工作，比如设置类加载器和后置处理器、配置不进行自动装配的类型、注册默认的环境bean；   
  4. 为context的子类提供后置处理bean factory的扩展能力。如果子类想在bean定义加载完成后，开始初始化上下文之前做一些特殊逻辑，可以复写这个方法；  
  5. 执行context中注册的bean factory后缀处理器；  
  6. 按优先级顺序在beanfactory中注册bean的后缀处理器，bean后置处理器可以在bean初始化前、后执行处理；  
  7. 初始化消息源，消息源用来支持消息的国际化；  
  8. 初始化应用事件广播器。事件广播器用来向applicationListener通知各种应用产生的事件，是一个标准的观察者模式；  
  9. 是留给子类的扩展步骤，用来让特定的context子类初始化其他的bean；  
  10. 把实现了ApplicationListener的bean注册到事件广播器，并对广播器中的早期未广播事件进行通知；  
  11. 冻结所有bean描述信息的修改，实例化非延迟加载的单例bean；  
  12. 完成上下文的刷新工作，调用LifecycleProcessor的onFresh()方法以及发布ContextRefreshedEvent事件；  
  13. 在finally中，执行第十三步，重置公共的缓存，比如ReflectionUtils中的缓存、AnnotationUtils中的缓存等等；

* Spring Bean的作用域（Scope）

  | 范围        | 描述                                                         |
  | ----------- | ------------------------------------------------------------ |
  | singleton   | 单例，将单个bean定义范围限定为每个Spring IoC容器的单个对象实例（默认） |
  | proptotype  | 任意数量的对象实例，每次请求创建新的实例，destroy方式不生效  |
  | request     | 每次http请求创建一个实例且仅在当前request有效（仅 Web 应用可用） |
  | session     | 将单个bean定义范围限定为HTTP的生命周期Session，在当前session内有效（仅 Web 应用可用） |
  | application | 一个 Web 应用仅创建一个bean（仅 Web 应用可用）               |
  | websocket   | 将单个bean定义到一个WebSocket会话（仅 Web 应用可用）         |


* Spring Bean的实例化方式

  1. `<bean>` / `@Bean` / `@Component` 的方式注册 Bean 后实例化  
  2. `FactoryBean` 实例化 bean  
  3. 静态工厂方法（ `factory-method` ）实例化 bean  
  4. 实例工厂方法（ `factory-bean` + `factory-method` ）实例化 bean  
  5. `InstantiationAwareBeanPostProcessor` 实例化 bean （该法比较特殊，它实际上是拦截原有 bean 的创建流程而已）


* Spring Bean的生命周期
  <img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/spring-bean-lifecyc.jpg" alt="spring bean声明周期" height=260/>


* AOP（面向切面编程）  

  > AOP 可以在不修改功能代码本身的前提下，使用运行时动态代理的技术对已有代码逻辑增强。AOP 可以实现组件化、可插拔式的功能扩展，通过简单配置即可将功能增强到指定的切入点。

  1. 底层设计是由运行时动态代理支撑，在 bean 的初始化流程中，借助 BeanPostProcessor 将原始的目标对象织入通知，生成代理对象。  
  2. AOP 是对原有业务逻辑的横切增强，使用不同的通知织入方式，它有不同的底层原理支撑（编译期、类加载器、对象创建期）。

  **JDK动态代理和Cglib动态代理的对比**:    

  1. JDK 动态代理要求被代理的对象所属类至少实现一个接口，它是 JDK 内置的机制  
  2. Cglib 通过用字节码增强技术实现，无此限制  
  3. JDK 动态代理的代理对象创建速度快，执行速度慢；Cglib 动态代理的代理对象创建速度慢，执行速度快

  **AOP术语**：  

  | 名称                 | 描述                                                         |
  | -------------------- | ------------------------------------------------------------ |
  | Advice（通知类型）   | 前置通知[Before]、返回通知[After-returning]、异常通知   [After-throwing]、后置通知[After]、环绕通知[Around] |
  | JoinPoint（连接点）  | 程序执行的某一特定位置                                       |
  | Pointcut（切点）     | 在指定策略下可能被拦截的方法                                 |
  | Aspect（切面）       | 切面由切点和通知结合                                         |
  | Introduction（引入） | 特定的增强代码（一般为类增加属性和方法）                     |
  | Weaving（织入）      | 将增加添加到目标类的具体连接点上的过程，Spring采用动态代理织 入 |
  | Proxy（代理）        | 类被AOP织入后生成一个结果类，它是融合了原类和增强逻辑的代理类 |

  **AOP应用场景**:  
    1.业务日志切面：可以记录业务方法调用的痕迹   
    2.事务控制：通过切面可以声明式控制事务  
    3.权限校验：执行方法之前先校验当前登录用户是否有权调用  
    4.数据缓存：执行方法之前先从缓存中取，取到则直接返回不走业务方法


### Spring Boot

* Spring boot & Spring Framework

  > SpringBoot 简化了基于 SpringFramework 的应用的开发，并不是成为SpringFramework 的替代品；SpringBoot 帮助开发人员整合不同场景下的依赖、提供默认的配置。

* Spring Boot特性

  1. 约定大于配置：对常见的场景都提供了约定的默认配置，并基于自动装配机制，将场景中通常必需的组件都注册好，以此来达到少配置、甚至不配置都能正常启动项目的效果；  
  2. 开箱即用的starter：对常用的场景都进行了整合，将这些场景中需要的依赖都收集整理到一个依赖中，并在其中添加了默认的配置，使项目开发中只需要导入一个依赖，即可实现场景技术的整合；  
  3. 自动装箱：基于 SpringFramework 的模块装配 + 条件装配，可以在具体的场景下，自动引入需要的配置类并解析执行；  
  4. 嵌入式Web容器：提供了内部嵌入式的 Web 容器来支撑应用的运行；
  5. 生产级别的特性：健康检查、监控指标、外部化配置等。

### 对象关系映射（ORM）

> 对象关系映射（Object Relation Mapping，简称ORM）是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。

  目前Java领域主流的ORM框架是Hiberate和Mybatis；主要实现程序对象到关系数据库数据的映射，我们使用ORM可以将我们的对象(或类)去进行映射，使得我们可以去操作对象就能完成对表的操作。

**Hibernate**:

> Hibernate对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系,其是一个全自动的ORM框架，可以自动生成SQL语句，自动执行。

    1. Hibernate对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。  
    2. Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化了dao层编码工作。  

* Hibernate开发步骤:

1. 创建持久化类  
2. 创建对象-关系映射文件  
3. 创建Hibernate配置文件  
4. 通过Hibernate API编写访问数据库的代码

**Mybatis**

> MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。

1. 需要使用映射文件 mapper.xml 定义 map规则和 SQL
2. 需要定义 mapper/DAO，基于 xml 规则，操作数据库

**MyBatis 与 Hibernate对比**

| ORM框架   | 优点                                     | 缺点                                 |
| --------- | ---------------------------------------- | ------------------------------------ |
| Hibernate | 简单场景不用写 SQL（HQL、Cretiria、SQL） | 不够直观，对DBA不友好(不利于SQL审计) |
| Mybatis   | 原生 SQL（XML 语法），直观，对 DBA 友好  | 繁琐，简单的语句也需要自己手写SQL    |


## 五.SQL&MySQL

* 数据库设计范式：

  1. 第一范式（1NF）：属于第一范式关系的所有属性都不可再分，即数据项不可分；   
  2. 第二范式（1NF）：若某关系R属于第一范式，消除非主属性对码的部分函数依赖 ；   
  3. 第三范式（3NF）：在满足 2NF 的基础上，消除非主属性对码的传递函数依赖  
  4. 巴斯-科德范式（BCNF）：在满足 3NF 的基础上，消除主属性对码的部分和传递函数依赖

* 结构化查询语言（SQL）：

  >  数据查询语言（DQL）、数据操作语言（DML）、事务控制语言（TCL）、数据定义语言（DDL）、指针控制语言（CCL）

###     数据库事务

* 事务特性（ACID）:

  1. 原子性（Atomicity）：事务要么全部完成，要么全部取消。 如果事务崩溃，状态回到事务开始之前（事务回滚）；  
  2. 隔离性（Isolation）: 如果2个事务 T1 和 T2 同时运行，事务 T1 和 T2 最终的结果是相同的，不管 T1和T2谁先结束；  
  3. 持久性（Durability）: 一旦事务提交，不管发生什么（崩溃或者出错），数据要保存不会丢失；  
  4. 一致性（Consistency）: 只有合法的数据（依照关系约束和函数约束）才能写入数据库。

* 事务的并发问题

  1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据；  
  2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致；  
  3. 幻读：一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的数据行。

* 事务隔离级别：

  1. 读未提交（Read uncommitted）：最低级别的隔离，以上问题均无法得到解决；  
  2. 读已提交（Read committed）：可以避免脏读，但无法解决不可重复读和幻读（Oracle、PostgreSQL、SQL Server默认模式）  
  3. 可重复读（Repeatable read）：确保事务可以多次从一个行数据中读取相同的值，可以避免脏读和不可重复读，仍会出现幻读问题（MySQL默认模式）  
  4. 串行化（Serializable）：最高级别的隔离，要求所有事务被串行执行，不存在以上并发问题

  四种隔离级别对比：   

  | 隔离级别 | 脏读 | 不可重复读 | 幻读 |
  | -------- | ---- | ---------- | ---- |
  | 读未提交 | 是   | 是         | 是   |
  | 读已提交 | 否   | 是         | 是   |
  | 可重复读 | 否   | 否         | 是   |
  | 串行化   | 否   | 否         | 否   |

### MySQL 

  MySQL 主要分为 Server 层和存储引擎层两部分：  
  1. Server层：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数，跨存储引擎的功能都在这一层实现。  
  2. 引擎层：负责数据的存储和提取。MySQL通过插件架构支持 InnoDB、MyISAM、Memory 等多个存储引擎，MySQL5.5.5 版本开始InnoDB是默认的存储引擎。

  SQL 语句在 MySQL 的各个功能模块中的执行流程 ：   
  <img src="https://github.com/JAVA-000/JAVA-000/tree/main/summary/assets/mysql-arch.png" alt="MySQL架构图" height=280/>

**MySQL日志**

* 重做日志（redo log）

  当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面。这便是是 MySQL 里的 WAL ( Write-Ahead Logging)技术，核心是就是先写日志，再写磁盘。

  InnoDB 的 redo log 是固定大小的，当文件写到末尾就会回到开头循环写。

  基于 redo log，InnoDB就可以基于crash-safe的能力，即可以保证即使数据库发生异常重启，之前提交的记录也不会丢失。

* 归档日志（binlog）

  redo log 是 InnoDB 引擎特有的日志，而 Server 层的日志，称为 binlog（归档日志），binlog 是逻辑日志，记录的SQL语句的原始逻辑

  redo log和binlog对比：

  1. redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用;
  2. redo log 是物理日志，记录的是数据页上的修改，binlog 是逻辑日志，记录的是这个语句的原始逻辑；
  3. redo log 大小固定用完会循环写，binlog 是追加写入的不会覆盖以前的日志

* 两阶段提交

  1. prepare阶段：写rodo-log 并将其标记为prepare状态
  2. commit阶段：写binlog 并将其标记为commit状态
  
* MySQL索引
  > 索引的出现是为了提高查询效率，提高读写效率的数据结构有：哈希表、有序数组和搜索树  
  
    哈希表适用于等值查询，在Memcached等缓存场景用得比较多；有序数组在等值查询和范围查询场景中的性能就都非常优秀，但其更新成本较高所以只适用于静态存储引擎；数据库的索引模型一般为搜索树。
  
    索引是在存储引擎层实现的，没有统一的索引标准，不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。
  
    在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。而且InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的，每一个索引在 InnoDB 里面对应一棵 B+ 树。
  
* MySQL主备复制原理

  1. MySQL 主节点将数据变更写入二进制日志( binog, 其中记录叫做二进制日志事件binary log events)
  2. MySQL 从节点将主节点的 binary log events 拷贝到它的中继日志(relay log)
  3. MySQL 从节点重放 relay log 中的事件，将数据变更反映它自己的数据

## 六.分库分表

**数据复制**
  主从结构解决了高可用，读扩展，但是单机容量不变，单机写性能无法解决。

### 垂直拆分

>拆库：将一个数据库，拆分成多个提供不同业务数据处理能力的数据库；  
>拆表：如果数据单表字段过多，将一个大表拆分成若干个字表。

**垂直拆分的优点**：  
1. 拆分后业务清晰、专库专用，便于管理和维护  
2. 可以实现热数据和冷数据的分离   
3. 可以作为微服务改造的基础  

**垂直拆分的问题**：  
1. 没有解决数据量大带来的性能损耗，读写压力依旧很大  
2. 对业务系统有较强的侵入性 ，不同的业务无法跨库关联join只能通过业务来关联
3. 有上限，拆分到一定程度就无法继续拆分

### 水平拆分

> 水平划分是根据一定规则，例如时间或id序列值等进行数据的拆分。拆分后每个数据库和表的结构一致，但是数据得以拆分，从而提升性能。

**水平拆分的优点**：  
1. 单库（表）的数据量得以减少，解决了容量问题
2. 提高了系统的稳定性和负载能力
3. 切分出的表结构相同，程序改动较少

**水平拆分的问题**：  
1. 拆分规则较难抽象
2. 数据分片在扩容时需要迁移
3. 系统和数据维护量增大
4. 依然存在跨库无法join等问题，同时涉及分布式事务，数据一致性等问题。

**分库or分表**：

> 一般情况下，如果数据本身的读写压力较大，磁盘 IO 已经成为瓶颈，那么分库比分表要好。 分库将数据分散到不同的数据库实例，使用不同的磁盘，从而可以并行提升整个集群的并行数 据处理能力。相反的情况下，可以尽量多考虑分表，降低单表的数据量，从而减少单表操作的 时间，同时也能在单个数据库上使用并行操作多个表来增加处理能力。

### 框架和中间件
* TDDL
* ShardingSphere
* DRDS
* MyCat/DBLE
* Cobar
* Vitness
* KingShard

### 数据迁移方案

**全量**
1. 业务系统停机  
2. 数据库迁移，校验一致性  
3. 然后业务系统升级，接入新数据库

**全量+增量**

1. 先同步数据到最近的某个时间戳  
2. 然后在发布升级时停机维护  
3. 再同步最后一段时间(通常是一天)的变化数据  
4. 最后升级业务系统，接入新数据库

**全量+增量+binlog**
  通过主库或者从库的 binlog 来解析和重新构造数据，实现复制。

##  七.RPC和微服务

### 远程服务调用

> RPC是远程过程调用（Remote Procedure Call）简称，指位于互不重合的内存地址空间中的两个程序，在语言层面上，以同步的方式使用带宽有限的信道来传输程序控制信息。

**RPC需要解决的问题**

- 数据如何表示：将交互双方所涉及的数据转换为某种事先约定好的中立数据流格式来进行传输，将数据流转换回不同语言中对应的数据类型来进行使用，即下序列化话合反序列化。常见而得序列化协议有：JSON、XML、Hessian、Protobuf、Thrift等
- 数据如何传递：如何通过网络在两个服务Endpoint之间相互操作、交换数据，可能需要解决异常、超时、安全、认证、授权、事务等问题。
- 如何确定方法：在服务提供方如何才能找到正确的服务提供方法调用

RPC核心调用流程如图：   ![rpc核心原理](file:///Users/ray/Downloads/summary(1)/rpc.png?lastModify=1612528665)

**RPC各部分职责**

1. RpcServer：负责导出远程接口
2. RpcClient：负责导入远程代理实现
3. RpcProxy：远程接口的代理实现
4. RpcInvoker：在服务调用方负责调用信息和发送调用请求到服务方并等待调用结果返回，在服务提供方其负责服务提供方接口的具体实现并返回调用结果
5. RpcProtocol：进行协议的编/解码
6. RpcConnectot：负责维持服务调用方到服务提供方的连接通道和发送数据到服务提供方
7. RpcAcceptor：接收服务调用方请求并返回请求结果
8. RpcProcessor：负责在服务提供方控控制调用过程，包括管理调用线程池和超时时间等
9. RpcChannel：数据传输通道

常见RPC框架对比：  

| 名称    | 开发语言 | 服务治理 | 序列化   | 注册中心 | 管理中心 | 跨语言 | 运维成本 | 机构   |
| ------- | -------- | -------- | -------- | -------- | -------- | ------ | -------- | ------ |
| Hession | 跨语言   | X        | hessian  | X        | X        | √      | 低       | Caucho |
| Montan  | Java     | √        | 多种     | √        | √        | X      | 中       | Weibo  |
| grpc    | 跨语言   | X        | protobuf | X        | X        | √      | 中       | Google |
| Thrift  | 跨语言   | √        | thrift   | √        | √        | X      | 中       | Apache |
| Dubbo   | Java     | √        | 多种     | √        | √        | X      | 中       | Apache |

**REST设计**

> REST与RPC在思想上差异的核心是抽象的目标不一样，既RPC是面向过程的编程思想，而REST是面向资源的编程思想。

1. 使用客户/服务器模型：客户和服务器之间通过一个统一的接口来互相通讯。  
2. 层次化的系统：在一个REST系统中，客户端并不会固定地与一个服务器打交道。  
3. 无状态：在一个REST系统中，服务端并不会保存有关客户的任何状态。也就是说，客户端自身负责用户状态的维持，并在每次发送请求时都需要提供足够的信息。  
4. 可缓存：REST系统需要能够恰当地缓存请求，以尽量减少服务端和客户端之间的信息传输，以提高性能。  
5. 统一的接口：一个REST系统需要使用一个统一的接口来完成子系统之间以及服务与用户之间的交互。这使得REST系统中的各个子系统可以独自完成演化。

### CAP理论

分布式系统的单个指标：   ![CAP](file:///Users/ray/Downloads/summary(1)/cap.jpg?lastModify=1612528665)

> Consistency（一致性）：在分布式系统中所有节点访问同一份最新的数据副本； Availability（可用性）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求； Partition tolerance（分区容错性）：分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务

  一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时得到满足。

### 微服务架构

> 微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。

**核心特征**

1. 围绕业务能力构建
2. 分析按治理
3. 通过服务来实现独立自治的组件
4. 产品化思维
5. 数据去中心化
6. 强终端弱管道
7. 容错性设计
8. 演进式设计
9. 基础设施自动化

**康威定律**

1. 组织沟通方式决定系统设计；
2. 时间再多一件事情也不可能做的完美，但总有时间做完一件事情；
3. 线型系统和线型组织架构间有潜在的异质同态特性；
4. 大的系统组织总是比小系统更倾向于分解。

**微服务组件**

- 传输通信：主流的传输通信方式有：Restful Api、Dubbo、grpc、Thrift

- 注册中心

  1. Eureka：典型的AP系统优先保证可用性，不要求强一致性保证最终一致性  
  2. Zookeeper：属于CP系统保证数据的强一致性，在进行Leader选举时会停止服务  
  3. Nacos：可选择AP还是CP模式，支持几乎所有主流类型的“服务”的发现、配置和管理、

  常见注册中心对比图：   ![注册中心](file:///Users/ray/Downloads/summary(1)/registry.jpg?lastModify=1612528665)

  

- 配置中心

  1. Spring Cloud Config：  
  2. Apollo  
  3. Nacos

  产品特性对比：  

  | 特性       | Spring Cloud Config      | Apollo                                    | Nacos                          |
  | ---------- | ------------------------ | ----------------------------------------- | ------------------------------ |
  | 配置推送   | 支持（Spring Cloud Bus） | 支持（HTTP长轮询）                        | 支持（HTTP长轮询）             |
  | 版本管理   | 支持（Git）              | 支持                                      | 支持                           |
  | 配置回滚   | 支持（Git）              | 支持                                      | 支持                           |
  | 灰度发布   | 支持                     | 支持                                      | 暂不支持                       |
  | 权限控制   | 支持                     | 支持                                      | 暂不支持                       |
  | 多语言     | 仅支持Java               | Go、C++、Java、Python、PHP、.NET、OpenApi | Python、Java、Node.js、OpenApi |
  | 通信协议   | HTTP和AMQP               | HTTP                                      | HTTP                           |
  | 数据一致性 | Git保证                  | 数据库模型消息队列                        | HTTP异步通知                   |
  | 监听查询   | 支持                     | 支持                                      | 支持                           |

  

- 负载均衡

  > 调度后方的多台机器，以统一的接口对外提供服务，承担此职责的技术组件。
  >
  > 根据均衡器的工作模式可分为：四层（网络层）负载均衡和七层（应用层）负载均衡

  负载均衡策略：

  1. 轮询均衡：每一次来自网络的请求轮流分配给内部中的服务器，从1至N然后重新开始
  2. 权重轮询：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求
  3. 随机轮询：将请求随机分配给内部中的多个服务器，在数据足够大的场景下能达到相对均衡的分布
  4. 权重随机：类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程
  5. 一致性哈希：根据请求中某一些数据作为特征值来计算需要落在的节点上，算法一般会保证同一个特征值每次都一定落在相同的服务器上
  6. 响应速度均衡：通过对服务器发送探测请求来确定最快响应时间，选择响应速度最快的服务器处理请求
  7. 最少连接速均衡：最少连接数均衡算法维护每台服务器的正在处理的请求数，当前请求分配给连接数最少的服务器

  常见的负载均衡组件有：Ribbon/Feign、Nginx、HAProxy、RPC Client

- 容错限流

  一个大的服务集群中，程序可能崩溃、节点可能宕机、网络可能中断等意外情况，提升系统的可用性，最低限度的保证分布式系统的可用行不出现倒退。

  容错策略对比：

  ![容错策略](file:///Users/ray/Downloads/summary(1)/fault-tolerance.png?lastModify=1612528665)

  限流策略：

  1. 流量计数器：设置一个计数器，根据当前时刻的流量计数结果是否超过阈值来决定是否限流。只能针对时间点进行离散的统计。  
  2. 滑动时间窗口：将时间窗口划分为更小的时间片段，每过一个时间片段，时间窗口就会往前滑动一格，每个时间片段都有独立的计数器。解决了流量计数器的缺陷，但适用于否决式限流，超过阈值的流量就必须强制失败或降级，很难进行阻塞等待处理。  
  3. 漏桶模式：一个以请求对象作为元素的先入先出队列（FIFO Queue），队列长度就相当于漏桶的大小，当队列已满时便拒绝新的请求进入。  
  4. 令牌桶模式：那就每间隔X/Y时间就往桶中放一个令牌，当有请求进来首先要获取到令牌才能继续处理，一旦发现没有令牌可取了，就马上失败或进入服务降级逻辑。

  常见的容错限流组件有：**Hystrix**、**Nginx/Kong + RateLimit**、**Sentinel**

- 网关&路由

  Zuul、Zuul2、Spring Cloud Gateway

## 八.分布式缓存

> 为了加速数据处理了访问效率，让系统访问更快的临时冗余数据；本质上缓存是典型以空间换时间来提升性能的手段。

- 缓存带来的好处：
  1. 缓解CPU压力：把方法运行结果存储起来、把原本要实时计算的内容提前算好、把一些公用的数据进行复用，这样既节省CPU算力也提升了响应性能。
  2. 为缓解I/O压力：把原本对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问，将原本对单点部件（如数据库）的读写访问变为到可扩缩部件（如缓存中间件）的访问，提升响应性能。
- 度量缓存的属性：
  1. 吞吐量：每秒操作数，缓存进行并发读、写操作的效率，即缓存本身的工作效率高低  
  2. 命中率：从缓存中返回结果次数与总请求次数的比值，反映了引入缓存的价值高低  
  3. 扩展功能：额外的最大容量、失效时间、失效事件、命中率统计等  
  4. 分布式支持：是否支持分布式部署及网络访问操作
- 适合缓存的数据
  1. 静态（准静态）数据：类似于字典表或部门结构等一般不发生变化的数据  
  2. 中间状态数据：经过计算的可复用中间结果数据
- 缓存淘汰策略
  1. FIFO：先进先出，优先淘汰最早进入被缓存的数据  
  2. LRU：优先淘汰最久未被访问过的数据  
  3. LFU：优先淘汰最不经常使用的数据
- 缓存的加载
  1. 启动时全量加载：系统启动时即加载
  2. 同步使用加载：读取缓存时若不存在同步加载
  3. 延迟异步加载：第一次读取缓不存在直接返回，同时启动异步线程加载数据
  4. 任务定时加载：有后台线程负责维护缓存数据，定时根据条件触发更新

**常见的缓存问题**

- 缓存穿透

  > 的并发请求访问不存在的缓存数据，导致请求压力直接透传到数据库，即缓存未能发挥应有作用的现象。

  解决办法：  

  1. 在一定时间内对返回为空的Key值依然进行缓存  
  2. 对于恶意攻击导致的缓存穿透，在缓存之前设置一个布隆过滤器来解决

- 缓存击穿

  > 缓存中某个热点数据十小时，此时有多个针对该数据的请求到来，这些请求全部未能命中缓存到达真实数据源中，导致其压力剧增的现象

  解决办法：  

  1. 加锁同步，以请求该数据的Key值为锁，使得只有第一个请求可以流入到真实的数据源中  
  2. 热点数据由代码来手动管理，有计划地完成更新、失效，避免由缓存的策略自动管理

- 缓存雪崩

  > 大批不同的数据在短时间内一起失效，导致了这些数据的请求都击穿了缓存到达数据源，令数据源在短时间内压力剧增。

  解决办法：  

  1. 提升缓存系统可用性，建设分布式缓存的集群  
  2. 将缓存的生存期从固定时间改为一个时间段内的随机时间

- 缓存污染

  > 缓存中的数据与真实数据源中的数据不一致的现象。 

**缓存和数据源的读写顺序**

1. 读数据时，先读缓存，缓存没有的话，再读数据源，然后将数据放入缓存，再响应请求  
2. 写数据时，先写数据源，然后失效（而不是更新）掉缓存

### Redis

Redis是多线程处理程序，但其是在6.0以前负责IO处理的是单线程处理模型，故我们常说Redis是单线程的；Redis6.0以后通过多线称I/O多路复用来处理请求提升性能。

- 基础数据结构：字符串（string）、散列表（hash）、列表（list）、集合（set）、有序集合（sorted set）

- 高级数据结构
  1. Bitmaps：适用于各种实时分析、存储与对象有关联的是否关系信息可以大幅节省空间
  2. HyperLogLog：用于计算唯一事物的概率数据结构
  3. GEO：地理位置经/纬度信息的储存，并提供了通用的操作方法
  
- 底层数据结构
  1. list：链表
  2. dict：使用双哈希表实现的, 支持平滑扩容的字典
  3. zskiplist：附加了后向指针的跳跃表
  4. intset：用于存储整数数值集合的自有结构
  5. ziplist：一种实现上类似于TLV, 但比TLV复杂的, 用于存储任意数据的有序序列的数据结构
  6. quicklist：一种以ziplist作为结点的双链表结构
  7. zipmap：一种用于在小规模场合使用的轻量级字典结构
  
- Redis 的使用场景：
  1. 业务数据缓存：热点数据缓存，会话或token缓存
  2. 全局一致计数：秒杀库存计数，全局ID生成等
  3. 高效统计计数：ID去重，UV、PV等访问量
  4. 简单发布订阅：基于Redis5.0新增的Stream模拟消息队列
  5. 分布式锁：setnx配合lua脚本保证原子性和事务

**主从复制**

**哨兵模式**

1. 监控主服务器和从服务器是否正常运行  
2. 主服务器出现故障时自动将从服务器转换为主服务器
- 优点  
哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有  
主从可以自动切换，系统更健壮，可用性更高  

- 缺点  
  Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂

**Redis-Cluster集群**

1. 所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽  
2. 节点的fail是通过集群中超过半数的节点检测失效时才生效  
3. 客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可

## 九.分布式消息队列

### 消息队列模型

1. 基于Queue的点对点模式
2. 基于Topic的发布/订阅模式

### 消息队列的作用
- 应用解耦：系统不直接调用，降低依赖，特别是不在线也能保持通信最终完成
- 异步处理：异步通信，减少线程等待，特别是处理批量等大事务、耗时操作
- 削峰填谷：当系统压力大的时候，缓冲部分请求消息在系统低峰期处理，类似于背压处理
- 消息通讯：提供多种消息模式、服务质量、顺序保障

### 消息处理语义

* At most once(至多一次)：消息可能丢失但是不会重复发送  
* At least once(至少一次)：消息不会丢失，但是可能会重复  
* Exactly once(精确一次)：每条消息肯定会被传输一次且仅一次

### 常见的消息协议
​     STOMP、JMS*、AMQP、MQTT、XMPP、Open Messaging

### 常见的消息中间件

**ActiveMQ**
* 特性：功能最全的开源消息队列，多种语言和协议编写客户端，支持所有主流的消息协议，完全支持JMS1.1和J2EE 1.4规范，与Spring很好地集成，支持通过JDBC和journal提供高速的消息持久化，实现了高性能的集群模式   
* 支持Queue和Topic两种消息投递模式

**Kafka**
* 常数时间复杂度的持久化能力和访问性能；单机支持每秒 100K 条以上消息的高吞吐率；支持服务端消息分区和分布式消费，保证单个分区内的消息顺序传输；同时支持数据实时和离线两种处理方式；支持在线增加broker节点，能够水平扩展

* 仅支持Topic的消息传递方式，但在Kafka中可以认为Queue是Topic只有一个分区，所有消费者均属同一消费者组时的特例

* 概念名词

  1. Broker：Kakfa集群中的一个服务节点
  2. Topic：属于kafka中的逻辑概念，可以理解为每条消息归属的类别
  3. Partition：数据物理概念，每个Topic可以有一个或多个分区
  4. Producer：消息生产者
  5. Consumer：消息消费者，每个消费者都有属于自己的消费位移（保存在服务端）
  6. Consumer Group：消费者组，每个消费者均会属于一个消费者组，Kafka保证Topic中消息仅被组内的一个消费者消费
  
  